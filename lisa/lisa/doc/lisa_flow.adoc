= Lisa documentation
Andy Nagels <thereisanewway@gmail.com>
:Author Initials: AN
:toc:
:icons:
:numbered:
:website: https://github.com/rockwolf/python/lisa

Lisa is a pyqt application that works in conjunction with a PostgresQL
database, to provide the user with an interface to store financial transactions.
It's main focus lies in creating a trading journal for active traders,
with support for commodities, cfd's etc.

.This document
**********************************************************************
This document describes the workflow of the code, in relation to using
the application.

It can help to get a clear view on the code structure, for developers.
**********************************************************************

[[btnadd]]
== Adding a transaction line
=== btn_add
This section describes what happens, if we enter data in the input fields and
press the 'add'-button.
Note: this only adds the input as a transaction line to the table-model in pyqt.
It will not do anything on the database yet.
Lisa uses the table in the gui as a first buffer, so you can look at the data and
make corrections when needed, before actually sending them to the database.

=== UI
Screenshot to be added.

=== Code
controller/controllerpyqt.py/btn_add_clicked
[source, python, numbered]
----
def btn_add_clicked(self):
    """
        Add new input to the input_fields table.
    """
    # Init tbl_data
    input_line = self.ctl.get_input_line() # <1>
    if self.model_data == None:
        self.init_tbl_data(input_line) # <2>
    else: 
        self.ctl.add_tbl_data(self.model_data, [input_line]) # <3>
    self.clear_fields()
----

<1> Gets data from the input fields, this is a first area of manipulation. Get_input_line his returns a dictionary of input values, adressable via keys.
<2> Makes sure we have a model connected to our table.
<3> Adds the inputline directly to the model via insertRows.

For the model to be created, the input line is retrieved. It is necessary to determine what values go into the table model.

[source, python, numbered]
----
def get_input_line(self):
    """
        Get the input values.
    """
    # initialize
    market = ''
    commodity = ''
    market_description = ''
    commodity_description = ''
    pool = DEFAULT_DECIMAL

    str_list = []
    for i in range(0,InputIndex.SIZE):
        str_list.append('')

    # get values    
    if(deals_with_commodities(self.gui.get_account_from(), self.gui.get_account_to())):
        market = self.gui.get_market_code()
        commodity = self.gui.get_commodity_name()
        market_description = self.gui.get_market_description()
        commodity_description = self.gui.get_commodity_description()
        pool = self.gui.get_pool()
        
    #TODO: check if it needs to be a negative amount
    if is_negative_amount(self.gui.get_account_from()) \
        and Decimal(amount) != DEFAULT_DECIMAL:
        amount = '-' + self.gui.get_amount()
    else:
        amount = self.gui.get_amount()
    
    str_list[InputIndex.DATE] = self.gui.get_date()
    str_list[InputIndex.ACCOUNT_FROM] = self.gui.get_account_from()
    str_list[InputIndex.ACCOUNT_TO] = self.gui.get_account_to()
    str_list[InputIndex.AMOUNT] = amount
    str_list[InputIndex.COMMENT] = self.gui.get_comment()
    str_list[InputIndex.COMMODITY] = commodity
    str_list[InputIndex.COMMODITY_DESCRIPTION] = commodity_description
    str_list[InputIndex.MARKET] = market
    str_list[InputIndex.MARKET_DESCRIPTION] = market_description
    str_list[InputIndex.QUANTITY] = self.gui.get_quantity()
    str_list[InputIndex.PRICE] = self.gui.get_price()
    str_list[InputIndex.COMMISSION] = self.gui.get_commission()
    str_list[InputIndex.TAX] = self.gui.get_tax()
    str_list[InputIndex.RISK] = self.gui.get_risk()
    str_list[InputIndex.CURRENCY_FROM] = self.gui.get_currency_from()
    str_list[InputIndex.CURRENCY_TO] = self.gui.get_currency_to()
    str_list[InputIndex.EXCHANGE_RATE] = self.gui.get_exchange_rate()
    str_list[InputIndex.MANUAL_COMMISSION] = self.gui.get_manual_commission()
    str_list[InputIndex.DATE_EXPIRATION] = self.gui.get_date_expiration()
    str_list[InputIndex.POOL] = pool
    return str_list
----

[[btnremove]]
== Removing a transaction line
=== btn_remove / btn_remove_last
This section describes the functionality between the remove and remove_last buttons.
Remove_last will remove the last entry from the table-model.
Remove will remove the currently selected entry from the table-model.
When nothing is selected, the last entry will be removed.

Note:
----
Currently, only removing the last entry is supported.
----

=== UI
Screenshot to be added.

=== Code
[source, python, numbered]
----
self.ctl.remove_last(self.model_data)
----

[source, python, numbered]
----
table_model.removeRows(table_model.rowCount(None) - 1, 1) # <1>
----

<1> This removes the last entry, based on the rowCount method of the model.

We can see that the table-model contains most of the functionality to
manipulate itself. Because of that, our application just needs to call
the correct functionality on the table model.

Also note that the model should refresh automatically, as that is the 
nature of working with model-views in (py)qt.

== Execute
=== btn_execute
This section will describe the most important step: processing the table-data.
Processing will calculate missing or extra values and writes it all to the
correct tables in the database.

=== UI
Screenshot to be added.

=== Code
[source, python, numbered]
----
    self.ctl.write_to_database(self.model_data) # <1>
    self.set_lbl_check(self.ctl.get_check_info([])) # <2>
    self.model_data.clear() # <3>
----

<1> The main processing is started from this function in the controller.
<2> Detailed info that is displayed, will change after processing, e.g. the total pool.
<3> After processing, the table-data is cleared again.

=== Code: write_to_database
This code will do the following:
- load the classes for currency_exchange, rate, finance and trade.
- get the input_fields
- process currency_exchange: get statements, print them and write them to the db
- process rate: get statements, print them and write them to the db
- process finance: get statements, print them and write them to the db
- process trade: get statements, print them and write them to the db

==== Code: get_input_fields
This function is a step inbetween, that performs typecasts on the inputs and makes
the values available via a dictionary.
Default empty/zero values are also filled in for the trade-related input fields, if they are not
used.

[source, python, numbered]
----
None 
----

----
// vim: set syntax=asciidoc:
----
